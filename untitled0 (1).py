# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NsfQEGjBY99rXG8Nh7DnCClc2SF80_bT
"""

class AkunBank:
  def __init__(self, saldo):
    self.__saldo = saldo #private attribute

  def cek_saldo(self):
    return self.__saldo

  def setor(self, jumlah):
    if jumlah > 0:
      self.__saldo += jumlah

rekening = AkunBank(1000)
rekening.setor(500)

print(rekening.cek_saldo())

#Analisis 1 & tugas 1
class Hero:
    def __init__(self, name, hp, attack_power):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power

    def info(self):
        print(f"Hero: {self.name} | HP: {self.hp} | Power: {self.attack_power}")

#---Main Program---

hero1 = Hero("Layla", 100, 15)
hero1.hp = 500
print(hero1.hp)

#Analisis 2 & tugas 2
class Hero:
    def __init__(self, name, hp, attack_power):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power

    def info(self):
        print(f"{self.name} | HP: {self.hp}")


    def serang(self, lawan):
        print(f"{self.name} menyerang {lawan.name}!")
        lawan.diserang(self.attack_power)  # Memanggil metode objek lawan

    def diserang(self, damage):
        self.hp -= damage
        print(f"{self.name} menerima {damage} damage! HP tersisa: {self.hp}")

#---Main Program---
hero1 = Hero("Layla", 100, 15)
hero2 = Hero("Gatotkaca", 120, 10)

print("--- SEBELUM BERTARUNG ---")
hero1.info()
hero2.info()

print("\n--- PROSES BERTARUNG ---")
hero1.serang(hero2)

print("\n--- SETELAH DISERANG ---")
hero2.info()

"""Analisis 2: Parameter lawan pada metode serang() harus berupa objek karena agar bisa mengakses metode lawan / lawan.diserang(damage) untk mengurangi hp lawan, bisa memodifikasi state lawan, menerapkan prinsip oop"""

# Analisis 3 (sebelum di bagian super() di hapus)
class Hero:
    def __init__(self, name, hp, attack_power):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power

    def info(self):
        print(f"{self.name} | HP: {self.hp} | Power: {self.attack_power}")

class Mage(Hero):
    def __init__(self, name, hp, attack_power, mana):
        super().__init__(name, hp, attack_power)  # âœ… Memanggil constructor parent
        self.mana = mana

    def info(self):
        print(f"{self.name} | HP: {self.hp} | Power: {self.attack_power} | Mana: {self.mana}")

# Penggunaan
eudora = Mage("Eudora", 80, 20, 100)
eudora.info()

# Analisis 3 setelah bagian super() di hapus
class Hero:
    def __init__(self, name, hp, attack_power):
        self.name = name
        self.hp = hp
        self.attack_power = attack_power

    def info(self):
        print(f"{self.name} | HP: {self.hp} | Power: {self.attack_power}")

class Mage(Hero):
    def __init__(self, name, hp, attack_power, mana):
        # super().__init__(name, hp, attack_power)
        self.mana = mana

    def info(self):
        print(f"{self.name} | HP: {self.hp} | Power: {self.attack_power} | Mana: {self.mana}")

# Penggunaan
eudora = Mage("Eudora", 80, 20, 100)
eudora.info()

# Analisis 4
class Hero:
  def __init__(self, nama, hp_awal):
    self.nama = nama
    # Enkapsulasi: HP bersifat Private (hanya bisa diakses di dalam class ini)
    self.__hp = hp_awal

  # GETTER: Cara resmi melihat HP
  def get_hp(self):
    return self.__hp

  # SETTER: Cara resmi mengubah HP (dengan validasi)
  def set_hp(self, nilai_baru):
    if nilai_baru < 0:
      self.__hp = 0 # HP tidak boleh negatif
    elif nilai_baru > 1000:
      print("Cheat terdeteksi! HP dimaksimalkan ke 1000 saja.")
      self.__hp = 1000
    else:
      self.__hp = nilai_baru

  def diserang(self, damage):
    # Kita pakai setter/getter bahkan di dalam class sendiri agar aman
    sisa_hp = self.get_hp() - damage
    self.set_hp(sisa_hp)
    print(f"{self.nama} terkena damage {damage}. Sisa HP: {self.get_hp()}")


# -- Uji Coba --
hero1 = Hero("Layla", 100)
# hero1.__hp = 9999 # GAGAL (Tidak akan mengubah hp asli)
# print(hero1.__hp) # ERROR (Tidak bisa dibaca langsung)
hero1.set_hp(-50) # Coba set negatif
print(hero1.get_hp()) # Output: 0 (Karena dicegat oleh logika Setter)

# Percobaan hacking
print(f"Mencoba akses paksa {hero1._Hero__hp}")

"""Analisis 4 poin 2: Pada percobaan hacking, nilai HP tetap muncuk karena mekanisme Name Mangling pada atribut private."""

# Analisis 4 sesudah (Tanpa validasi)
class Hero:
  def __init__(self, nama, hp_awal):
    self.nama = nama
    # Enkapsulasi: HP bersifat Private (hanya bisa diakses di dalam class ini)
    self.__hp = hp_awal

  # GETTER: Cara resmi melihat HP
  def get_hp(self):
    return self.__hp

  # hapus validasi
  def set_hp(self, nilai_baru):
      self.__hp = nilai_baru

  def diserang(self, damage):
    # Kita pakai setter/getter bahkan di dalam class sendiri agar aman
    sisa_hp = self.get_hp() - damage
    self.set_hp(sisa_hp)
    print(f"{self.nama} terkena damage {damage}. Sisa HP: {self.get_hp()}")


# -- Uji Coba --
hero1 = Hero("Layla", 100)
# hero1.__hp = 9999 # GAGAL (Tidak akan mengubah hp asli)
# print(hero1.__hp) # ERROR (Tidak bisa dibaca langsung)
hero1.set_hp(-50) # Coba set negatif
print(hero1.get_hp()) # Output: -50 (Karena dicegat oleh logika Setter)

# Uji validasi
hero1.set_hp(-100)

"""Data HP Hero menjadi tidak valid karena bisa bernilai negatif akibat tidak adanya validasi. Setter menjaga HP tetap valid sehingga data aman, logis dan game tidak rusak"""

# Analisis 5 sebelum di hapus
from abc import ABC, abstractmethod
# 1. Interface / Abstract Class (Kontrak)
class GameUnit(ABC):
    @abstractmethod
    def serang(self, target):
        pass

    @abstractmethod
    def info(self):
        pass

# 2. Implementasi pada Class Hero (Memenuhi Kontrak)
class Hero(GameUnit):
    def __init__(self, name):
        self.name = name

    def serang(self, target):
        print(f"Hero {self.name} menembus {target}!")


    def info(self):
        print(f"Saya adalah Hero: {self.name}")

# 3. Implementasi pada Class Monster (Memenuhi Kontrak)
class Monster(GameUnit):
    def __init__(self, jenis):
        self.jenis = jenis

    def serang(self, target):
        print(f"Monster {self.jenis} menggigit {target}!")

    def info(self):
        print(f"Saya adalah Monster: {self.jenis}")

#---Main Program---
hero = Hero("Layla")
monster = Monster("Zilong")

hero.info()
monster.info()
hero.serang(monster.jenis)

# Analisis 5 setelah di hapus

from abc import ABC, abstractmethod

# 1. Interface / Abstract Class (Kontrak)
class GameUnit(ABC):
    @abstractmethod
    def serang(self, target):
        pass

    @abstractmethod
    def info(self):
        pass

# 2. Implementasi pada Class Hero (Melanggar Kontrak)
class Hero(GameUnit):
    def __init__(self, name):
        self.name = name


    # def serang(self, target):
    #     print(f"Hero {self.name} menembus {target}!")

    def info(self):
        print(f"Saya adalah Hero: {self.name}")

# 3. Implementasi pada Class Monster (Memenuhi Kontrak)
class Monster(GameUnit):
    def __init__(self, jenis):
        self.jenis = jenis

    def serang(self, target):
        print(f"Monster {self.jenis} menggigit {target}!")

    def info(self):
        print(f"Saya adalah Monster: {self.jenis}")

#---Main Program---
hero = Hero("Layla")

# Analisis 6 (Hanya definisi class tanpa polymorphism)

class Hero:
    def __init__(self, name):
        self.name = name

    def serang(self):
        print(f"Hero {self.name} menyerang dengan tangan kosong.")

class Mage(Hero):
    def serang(self):
        print(f"{self.name} (Mage) menembakkan Bola Api! Boom!")

class Archer(Hero):
    def serang(self):
        print(f"{self.name} (Archer) memanah dari jauh! Jeb!")

class Fighter(Hero):
    def serang(self):
        print(f"{self.name} (Fighter) memukul dengan pedang! Slash!")

# Analisis 6 (Dengan polymorphism (Looping objectnya ))

class Hero:
    def __init__(self, name):
        self.name = name

    def serang(self):
        print(f"Hero {self.name} menyerang dengan tangan kosong.")

class Mage(Hero):
    def serang(self):
        print(f"{self.name} (Mage) menembakkan Bola Api! Boom!")

class Archer(Hero):
    def serang(self):
        print(f"{self.name} (Archer) memanah dari jauh! Jeb!")

class Fighter(Hero):
    def serang(self):
        print(f"{self.name} (Fighter) memukul dengan pedang! Slash!")

# -- Penerapan Polymorphism --
# Daftar campuran objek berbeda tipe
pasukan = [
    Mage("Eudora"),
    Archer("Miya"),
    Fighter("Zilong"),
    Mage("Gord")
]

print("--- PERANG DIMULAI ---")
# Satu perintah loop, tapi respon berbeda-beda (Polymorphism)
for pahlawan in pasukan:
    pahlawan.serang()

from abc import ABC, abstractmethod


# =========================
# ABSTRACT CLASS
# =========================
class BarangElektronik(ABC):
    def __init__(self, nama, stok, harga_dasar):
        self.nama = nama
        self.__stok = stok
        self.__harga_dasar = harga_dasar

    # ===== Encapsulation =====
    @property
    def stok(self):
        return self.__stok

    @property
    def harga_dasar(self):
        return self.__harga_dasar

    def tambah_stok(self, jumlah):
        if jumlah < 0:
            print(f"Gagal update stok {self.nama}: stok tidak boleh negatif ({jumlah})")
        else:
            self.__stok += jumlah
            print(f"Berhasil menambahkan stok {self.nama}: {self.__stok} unit")

    def ubah_stok(self, jumlah):
        if self.__stok - jumlah < 0:
            raise ValueError("Stok tidak mencukupi!")
        self.__stok -= jumlah

    # ===== Abstract Method =====
    @abstractmethod
    def hitung_harga_total(self, jumlah):
        pass

    @abstractmethod
    def tampilkan_detail(self):
        pass


# =========================
# LAPTOP
# =========================
class Laptop(BarangElektronik):
    PAJAK = 0.10

    def __init__(self, nama, stok, harga_dasar, processor):
        super().__init__(nama, stok, harga_dasar)
        self.processor = processor

    def hitung_harga_total(self, jumlah):
        pajak = self.harga_dasar * self.PAJAK
        total = (self.harga_dasar + pajak) * jumlah
        return pajak, total

    def tampilkan_detail(self):
        print(f"[LAPTOP] {self.nama} | Proc: {self.processor}")


# =========================
# SMARTPHONE
# =========================
class Smartphone(BarangElektronik):
    PAJAK = 0.05

    def __init__(self, nama, stok, harga_dasar, kamera):
        super().__init__(nama, stok, harga_dasar)
        self.kamera = kamera

    def hitung_harga_total(self, jumlah):
        pajak = self.harga_dasar * self.PAJAK
        total = (self.harga_dasar + pajak) * jumlah
        return pajak, total

    def tampilkan_detail(self):
        print(f"[SMARTPHONE] {self.nama} | Cam: {self.kamera}")


# =========================
# FITUR KERANJANG BELANJA
# =========================
def proses_transaksi(daftar_barang):
    total_tagihan = 0

    print("\n--- STRUK TRANSAKSI ---")

    for barang, jumlah in daftar_barang:
        pajak, subtotal = barang.hitung_harga_total(jumlah)

        barang.ubah_stok(jumlah)

        print(f"{barang.nama}")
        print(f"Harga Dasar: Rp {barang.harga_dasar:,}")
        print(f"Pajak: Rp {int(pajak):,}")
        print(f"Beli: {jumlah} unit | Subtotal: Rp {int(subtotal):,}\n")

        total_tagihan += subtotal

    print(f"TOTAL TAGIHAN: Rp {int(total_tagihan):,}")


# =========================
# MAIN PROGRAM (USER STORY)
# =========================
if __name__ == "__main__":

    print("--- SETUP DATA ---")

    laptop = Laptop("ROG Zephyrus", 0, 20_000_000, "Ryzen 9")
    hp = Smartphone("iPhone 13", 0, 15_000_000, "12MP")

    laptop.tambah_stok(10)
    laptop.tambah_stok(-5)  # gagal
    hp.tambah_stok(20)

    keranjang = [
        (laptop, 2),
        (hp, 1)
    ]

    proses_transaksi(keranjang)